"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var cik_by_symbol_1 = require("../../util/cik-by-symbol");
var Client_1 = require("../Client");
var DocumentParser_1 = require("../DocumentParser");
var ReportParser_1 = require("../ReportParser");
var RequestWrapper_1 = require("./RequestWrapper");
var Throttler_1 = require("./Throttler");
/**
 * Gets reports from companies filed with the SEC
 *
 * @see https://www.sec.gov/edgar/sec-api-documentation
 */
var SecEdgarApi = /** @class */ (function () {
    function SecEdgarApi(args) {
        if (args === void 0) { args = {
            client: new Client_1.default(),
            throttler: new Throttler_1.default(),
            cikBySymbol: cik_by_symbol_1.default,
            reportParser: new ReportParser_1.default(),
            documentParser: new DocumentParser_1.default(),
        }; }
        var client = args.client, throttler = args.throttler, cikBySymbol = args.cikBySymbol, reportParser = args.reportParser, documentParser = args.documentParser;
        this.client = client;
        this.throttler = throttler;
        this.cikBySymbol = cikBySymbol;
        this.reportParser = reportParser;
        this.documentParser = documentParser;
        this.baseUrlEdgar = 'https://data.sec.gov';
        this.baseUrlSec = 'https://www.sec.gov';
    }
    SecEdgarApi.prototype.request = function (url, isText) {
        if (isText === void 0) { isText = false; }
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2 /*return*/, new Promise(function (resolve, reject) { return __awaiter(_this, void 0, void 0, function () {
                        var _this = this;
                        return __generator(this, function (_a) {
                            this.throttler.add(function () { return __awaiter(_this, void 0, void 0, function () {
                                var response, responseData, e_1;
                                var _a, _b;
                                return __generator(this, function (_c) {
                                    switch (_c.label) {
                                        case 0:
                                            _c.trys.push([0, 2, , 3]);
                                            return [4 /*yield*/, this.client.request({
                                                    url: url,
                                                    onError: function (err) { return reject(err); },
                                                })];
                                        case 1:
                                            response = _c.sent();
                                            responseData = (_b = (_a = response.data) === null || _a === void 0 ? void 0 : _a.toString('utf-8')) !== null && _b !== void 0 ? _b : null;
                                            if (response.statusCode >= 400 || typeof responseData !== 'string') {
                                                reject("Request failed with status ".concat(response.statusCode, " ").concat(response.message));
                                            }
                                            resolve((isText ? responseData : JSON.parse(responseData)));
                                            return [3 /*break*/, 3];
                                        case 2:
                                            e_1 = _c.sent();
                                            reject(e_1);
                                            return [3 /*break*/, 3];
                                        case 3: return [2 /*return*/];
                                    }
                                });
                            }); });
                            return [2 /*return*/];
                        });
                    }); })];
            });
        });
    };
    SecEdgarApi.prototype.mapFilingListDetails = function (cik, filingListDetails) {
        var _a;
        var filings = [];
        for (var key in filingListDetails) {
            var k = key;
            var dataArr = filingListDetails[k];
            for (var i = 0; i < dataArr.length; i++) {
                filings[i] = (_a = filings[i]) !== null && _a !== void 0 ? _a : {};
                var filing = filings[i];
                filing[k] = dataArr[i];
            }
        }
        for (var _i = 0, filings_1 = filings; _i < filings_1.length; _i++) {
            var filing = filings_1[_i];
            var accessionStr = filing.accessionNumber.replace(/-/g, '');
            var primaryDocument = filing.primaryDocument;
            filing.url = "https://www.sec.gov/Archives/edgar/data/".concat(Number(cik), "/").concat(accessionStr, "/").concat(primaryDocument);
        }
        return filings;
    };
    SecEdgarApi.prototype.getCreateRequestSubmissions = function (params, forms) {
        var symbol = params.symbol, filings = params.filings, _a = params.cutoffDate, cutoffDate = _a === void 0 ? new Date('1970-01-01') : _a;
        var cik = this.getCikString(symbol);
        var filingsArr = Array.isArray(filings) ? filings : this.mapFilingListDetails(cik, filings);
        return filingsArr.filter(function (_a) {
            var form = _a.form, filingDate = _a.filingDate;
            return forms.includes(form) && new Date(filingDate).getTime() > cutoffDate.getTime();
        });
    };
    /**
     * If symbol is not in cikBySymbol, assume it is a cik. does not make a request
     */
    SecEdgarApi.prototype.getCikString = function (symbol) {
        var cik = this.cikBySymbol[symbol];
        if (cik)
            return cik.toString().padStart(10, '0');
        if (!isNaN(Number(symbol)))
            return Number(symbol).toString().padStart(10, '0');
        throw new Error("".concat(symbol, " is not a known symbol or valid cik"));
    };
    /**
     * This JSON data structure contains metadata such as current name, former name,
     * and stock exchanges and ticker symbols of publicly-traded companies. The object’s
     * property path contains at least one year’s of filing or to 1,000 (whichever is more)
     * of the most recent filings in a compact columnar data array. If the entity has
     * additional filings, files will contain an array of additional JSON files and the
     * date range for the filings each one contains.
     *
     * endpoint: `/submissions/CIK${cik}.json`
     */
    SecEdgarApi.prototype.getSubmissions = function (params) {
        return __awaiter(this, void 0, void 0, function () {
            var symbol, includeTranslated, cik, submissions;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        symbol = params.symbol, includeTranslated = params.includeTranslated;
                        cik = this.getCikString(symbol);
                        return [4 /*yield*/, this.request("".concat(this.baseUrlEdgar, "/submissions/CIK").concat(cik, ".json"))];
                    case 1:
                        submissions = _a.sent();
                        submissions.cik = Number(submissions.cik);
                        if (!includeTranslated)
                            return [2 /*return*/, submissions];
                        submissions.filings.recentTranslated = this.mapFilingListDetails(cik, submissions.filings.recent);
                        return [2 /*return*/, submissions];
                }
            });
        });
    };
    /**
     * The company-concept API returns all the XBRL disclosures from a single company (CIK)
     * and concept (a taxonomy and tag) into a single JSON file, with a separate array
     * of facts for each units on measure that the company has chosen to disclose
     * (e.g. net profits reported in U.S. dollars and in Canadian dollars).
     *
     * endpoint `/api/xbrl/companyconcept/CIK${cik}/${taxonomy}/${fact}.json`
     */
    SecEdgarApi.prototype.getFact = function (params) {
        return __awaiter(this, void 0, void 0, function () {
            var symbol, fact, _a, taxonomy, cik;
            return __generator(this, function (_b) {
                symbol = params.symbol, fact = params.fact, _a = params.taxonomy, taxonomy = _a === void 0 ? 'us-gaap' : _a;
                cik = this.getCikString(symbol);
                return [2 /*return*/, this.request("".concat(this.baseUrlEdgar, "/api/xbrl/companyconcept/CIK").concat(cik, "/").concat(taxonomy, "/").concat(fact, ".json"))];
            });
        });
    };
    /**
     * Returns all the company concepts data for a company into a single API call:
     *
     * endpoint `/api/xbrl/companyconcept/CIK${cik}/${taxonomy}/${fact}.json`
     */
    SecEdgarApi.prototype.getFacts = function (params) {
        return __awaiter(this, void 0, void 0, function () {
            var symbol, cik;
            return __generator(this, function (_a) {
                symbol = params.symbol;
                cik = this.getCikString(symbol);
                return [2 /*return*/, this.request("".concat(this.baseUrlEdgar, "/api/xbrl/companyfacts/CIK").concat(cik, ".json"))];
            });
        });
    };
    /**
     * The xbrl/frames API aggregates one fact for each reporting entity that is last filed
     * that most closely fits the calendrical period requested. This API supports for annual,
     * quarterly and instantaneous data:
     *
     * data.sec.gov/api/xbrl/frames/us-gaap/AccountsPayableCurrent/USD/CY2019Q1I.json
     *
     * Where the units of measure specified in the XBRL contains a numerator and a denominator,
     * these are separated by “-per-” such as “USD-per-shares”. Note that the default unit
     * in XBRL is “pure”.
     *
     * The period format is CY#### for annual data (duration 365 days +/- 30 days), CY####Q#
     * for quarterly data (duration 91 days +/- 30 days), and CY####Q#I for instantaneous data.
     * Because company financial calendars can start and end on any month or day and even
     * change in length from quarter to quarter to according to the day of the week, the frame
     * data is assembled by the dates that best align with a calendar quarter or year. Data
     * users should be mindful different reporting start and end dates for facts contained
     * in a frame.
     *
     * endpoint `/api/xbrl/frames/${taxonomy}/${fact}/${unit}/${frame}.json`
     */
    SecEdgarApi.prototype.getFactFrame = function (params) {
        return __awaiter(this, void 0, void 0, function () {
            var fact, frame, _a, taxonomy, _b, unit;
            return __generator(this, function (_c) {
                fact = params.fact, frame = params.frame, _a = params.taxonomy, taxonomy = _a === void 0 ? 'us-gaap' : _a, _b = params.unit, unit = _b === void 0 ? 'pure' : _b;
                return [2 /*return*/, this.request("".concat(this.baseUrlEdgar, "/api/xbrl/frames/").concat(taxonomy, "/").concat(fact, "/").concat(unit, "/").concat(frame, ".json"))];
            });
        });
    };
    /**
     * Note: Properties that are not provied from report are calculated an may not be accurate,
     * verify results finance.yahoo.com (ex: https://finance.yahoo.com/quote/AAPL/financials)
     *
     * Please contribute to improve resolving report properties: https://github.com/andyevers/sec-edgar-api
     *
     * Parses reports from company facts. Calculates missing properties and uses a single interface
     * for all reports. This includes only 10-K and 10-Q annual and quarterly reports. To include
     * all reports, use getReportsRaw.
     */
    SecEdgarApi.prototype.getReports = function (params) {
        return __awaiter(this, void 0, void 0, function () {
            var symbol, _a, withWrapper, _b, usePropertyResolver, facts, reports;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        symbol = params.symbol, _a = params.withWrapper, withWrapper = _a === void 0 ? false : _a, _b = params.usePropertyResolver, usePropertyResolver = _b === void 0 ? true : _b;
                        return [4 /*yield*/, this.getFacts({ symbol: symbol })];
                    case 1:
                        facts = _c.sent();
                        reports = this.reportParser.parseReports(facts, usePropertyResolver);
                        return [2 /*return*/, withWrapper ? reports : reports.map(function (report) { return report.getReport(); })];
                }
            });
        });
    };
    /**
     * Parses reports from company facts. Calculates missing properties and uses a single interface
     * for all reports.
     */
    SecEdgarApi.prototype.getReportsRaw = function (params) {
        return __awaiter(this, void 0, void 0, function () {
            var facts;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getFacts(params)];
                    case 1:
                        facts = _a.sent();
                        return [2 /*return*/, this.reportParser.parseReportsRaw(facts)];
                }
            });
        });
    };
    /**
     * Gets a list of all tickers and CIKs from `https://www.sec.gov/files/company_tickers.json`
     *
     * Note that they key cik_str is actually a number. To get cik string, you can do `${cik_str}`.padStart(10, '0')
     */
    SecEdgarApi.prototype.getCompanyTickerList = function () {
        return __awaiter(this, void 0, void 0, function () {
            var response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.request("".concat(this.baseUrlSec, "/files/company_tickers.json"))];
                    case 1:
                        response = _a.sent();
                        return [2 /*return*/, Object.values(response)];
                }
            });
        });
    };
    /**
     * Gets a list of all tickers and CIKs with exchange and company name from `https://www.sec.gov/files/company_tickers_exchange.json`
     *
     * response: { fields: ['cik', 'name', 'ticker', 'exchange'], data: [ [320193,'Apple Inc.','AAPL','Nasdaq'], ... ] }
     */
    SecEdgarApi.prototype.getCompanyTickerExchangeList = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.request("".concat(this.baseUrlSec, "/files/company_tickers_exchange.json"))];
            });
        });
    };
    /**
     * Gets a list of all mutual funds from `https://www.sec.gov/files/company_tickers_mf.json`
     *
     * response: { fields: ['cik','seriesId','classId','symbol'], data: [ [2110,'S000009184','C000024954','LACAX'], ... ] }
     */
    SecEdgarApi.prototype.getMutualFundList = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.request("".concat(this.baseUrlSec, "/files/company_tickers_mf.json"))];
            });
        });
    };
    /**
     * Gets a raw xml document string. the parameters are found in the submission list response. (response.filings.recent or response.filings.recentTranslated)
     *
     * Some form types can be parsed using the DocumentParser such as form 4 (insider transactions) and form 13g (institutional holders)
     *
     * endpoint: `https://www.sec.gov/Archives/edgar/data/${cik}/${accessionNumber}/${primaryDocument}`
     *
     * @see https://www.sec.gov/forms for a list of form types
     */
    SecEdgarApi.prototype.getDocumentXML = function (params) {
        return __awaiter(this, void 0, void 0, function () {
            var accessionNumber, primaryDocument, symbol, cik;
            return __generator(this, function (_a) {
                accessionNumber = params.accessionNumber, primaryDocument = params.primaryDocument, symbol = params.symbol;
                cik = this.cikBySymbol[symbol];
                return [2 /*return*/, this.request("".concat(this.baseUrlSec, "/Archives/edgar/data/").concat(cik, "/").concat(accessionNumber.replace(/-/g, ''), "/").concat(primaryDocument), true)];
            });
        });
    };
    /**
     * Gets a raw xml document string. the url is found in the submission list response. (response.filings.recentTranslated.url)
     *
     * Some form types can be parsed using the DocumentParser such as form 4 (insider transactions) and form 13g (institutional holders)
     *
     * endpoint: `https://www.sec.gov/Archives/edgar/data/${cik}/${accessionNumber}/${primaryDocument}`
     *
     * @see https://www.sec.gov/forms for a list of form types
     */
    SecEdgarApi.prototype.getDocumentXMLByUrl = function (params) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.request(params.url, true)];
            });
        });
    };
    /**
     * Used for getting insider transactions. extracts insider transaction urls from submission list response, and parses the xml doc.
     *
     * ```ts
     * const submissions = await secEdgarApi.getSubmissions({ symbol: 'AAPL' })
     * const requestWrapper = secEdgarApi.createRequestInsiderTransactions({ symbol: 'AAPL', filings: submissions.filings.recent })
     *
     * const transactions1 = (await requestWrapper.requestNext()).result.transactions // array of transactions from most recent doc
     * const transactions2 = (await requestWrapper.requestNext()).result.transactions // array of transactions from second most recent doc
     * ```
     */
    SecEdgarApi.prototype.createRequestInsiderTransactions = function (params) {
        var _this = this;
        var submissions = this.getCreateRequestSubmissions(params, ['4', '4/A', '5', '5/A']);
        var options = { maxRequests: params.maxRequests };
        var sendRequest = function (params) { return __awaiter(_this, void 0, void 0, function () {
            var _a, _b;
            var _c;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        _b = (_a = this.documentParser).parseForm4;
                        _c = {};
                        return [4 /*yield*/, this.getDocumentXMLByUrl(params)];
                    case 1: return [2 /*return*/, _b.apply(_a, [(_c.xml = _d.sent(), _c)])];
                }
            });
        }); };
        return new RequestWrapper_1.default({ submissions: submissions, options: options, sendRequest: sendRequest });
    };
    /**
     * Used for getting institutional holders. extracts holders urls from submission list response, and parses the xml doc.
     *
     * ```ts
     * const submissions = await secEdgarApi.getSubmissions({ symbol: 'AAPL' })
     * const requestWrapper = secEdgarApi.createRequestInstitutionalHolders({ symbol: 'AAPL', filings: submissions.filings.recent })
     *
     * const holders1 = (await requestWrapper.requestNext()).result.holders // array of holders from most recent doc
     * const holders2 = (await requestWrapper.requestNext()).result.holders // array of holders from second most recent doc
     * ```
     */
    SecEdgarApi.prototype.createRequestInstitutionalHolders = function (params) {
        var _this = this;
        var submissions = this.getCreateRequestSubmissions(params, ['SC 13G', 'SC 13G/A']);
        var options = { maxRequests: params.maxRequests };
        var sendRequest = function (params) { return __awaiter(_this, void 0, void 0, function () {
            var _a, _b;
            var _c;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        _b = (_a = this.documentParser).parseForm13g;
                        _c = {};
                        return [4 /*yield*/, this.getDocumentXMLByUrl(params)];
                    case 1: return [2 /*return*/, _b.apply(_a, [(_c.xml = _d.sent(), _c)])];
                }
            });
        }); };
        return new RequestWrapper_1.default({ submissions: submissions, options: options, sendRequest: sendRequest });
    };
    /**
     * Used for getting earnings report tables from submission files.
     *
     * ```ts
     * const submissions = await secEdgarApi.getSubmissions({ symbol: 'AAPL' })
     * const requestWrapper = secEdgarApi.createRequesEarningsReports({ symbol: 'AAPL', filings: submissions.filings.recent })
     *
     * const tables1 = (await requestWrapper.requestNext()).result.tables // array of tables from most recent doc
     * const tables2 = (await requestWrapper.requestNext()).result.tables // array of tables from second most recent doc
     * ```
     */
    SecEdgarApi.prototype.createRequestEarningsReports = function (params) {
        var _this = this;
        var submissions = this.getCreateRequestSubmissions(params, ['10-Q', '10-Q/A', '10-K', '10-K/A']);
        var options = { maxRequests: params.maxRequests };
        var sendRequest = function (params) { return __awaiter(_this, void 0, void 0, function () {
            var _a, _b;
            var _c;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        _b = (_a = this.documentParser).parseForm10k;
                        _c = {};
                        return [4 /*yield*/, this.getDocumentXMLByUrl(params)];
                    case 1: return [2 /*return*/, _b.apply(_a, [(_c.xml = _d.sent(), _c)])];
                }
            });
        }); };
        return new RequestWrapper_1.default({ submissions: submissions, options: options, sendRequest: sendRequest });
    };
    /**
     * Proxy statement includes list of holders, executiveCompensation, and other tables. returns FormDef14aData
     *
     * ```ts
     * const submissions = await secEdgarApi.getSubmissions({ symbol: 'AAPL' })
     * const requestWrapper = secEdgarApi.createRequesProxyStatement({ symbol: 'AAPL', filings: submissions.filings.recent })
     *
     * const { holders, executiveCompensation } = (await requestWrapper.requestNext()).result
     * ```
     */
    SecEdgarApi.prototype.createRequestProxyStatement = function (params) {
        var _this = this;
        var submissions = this.getCreateRequestSubmissions(params, ['DEF 14A']);
        var options = { maxRequests: params.maxRequests };
        var sendRequest = function (params) { return __awaiter(_this, void 0, void 0, function () {
            var _a, _b;
            var _c;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        _b = (_a = this.documentParser).parseFormDef14a;
                        _c = {};
                        return [4 /*yield*/, this.getDocumentXMLByUrl(params)];
                    case 1: return [2 /*return*/, _b.apply(_a, [(_c.xml = _d.sent(), _c)])];
                }
            });
        }); };
        return new RequestWrapper_1.default({ submissions: submissions, options: options, sendRequest: sendRequest });
    };
    return SecEdgarApi;
}());
exports.default = SecEdgarApi;
