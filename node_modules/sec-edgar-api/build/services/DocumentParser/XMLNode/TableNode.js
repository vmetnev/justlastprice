"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.TableNode = void 0;
var XMLNode_1 = require("./XMLNode");
var TableNode = /** @class */ (function (_super) {
    __extends(TableNode, _super);
    function TableNode() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.title = null;
        _this.headerRow = null;
        return _this;
    }
    TableNode.prototype.getTitle = function () {
        var _a;
        return (_a = this.title) !== null && _a !== void 0 ? _a : '';
    };
    TableNode.prototype.setTitle = function (title) {
        this.title = title;
    };
    TableNode.prototype.getChildren = function () {
        return _super.prototype.getChildren.call(this);
    };
    TableNode.prototype.removeTopChild = function () {
        this.removeChild(this.getChildren()[0]);
    };
    TableNode.prototype.removeEmptyTopRows = function () {
        var _a;
        while ((_a = this.getChildren()[0]) === null || _a === void 0 ? void 0 : _a.getIsEmpty()) {
            this.removeChild(this.getChildren()[0]);
        }
    };
    TableNode.prototype.prependChild = function (node) {
        var prevTopChild = this.getChildren()[0];
        this.getChildren().unshift(node);
        if (node.getParent() !== this)
            node.setParent(this);
        prevTopChild === null || prevTopChild === void 0 ? void 0 : prevTopChild.setPreviousSibling(node);
        var colArrTop = [];
        var colArrBottom = [];
        node.getChildren().forEach(function (col) {
            colArrTop.push(col);
            Array.from({ length: col.getColSpan() - 1 }).forEach(function () { return colArrTop.push(col); });
        });
        prevTopChild === null || prevTopChild === void 0 ? void 0 : prevTopChild.getChildren().forEach(function (col, i) {
            colArrBottom.push(col);
            Array.from({ length: col.getColSpan() - 1 }).forEach(function () { return colArrBottom.push(col); });
            if (!col.getTopSiblings().includes(colArrTop[i])) {
                col.addTopSibling(colArrTop[i]);
            }
        });
    };
    TableNode.prototype.toArray = function (parseValues) {
        if (parseValues === void 0) { parseValues = true; }
        return this.getChildren().map(function (row) { return row.toArray(parseValues); });
    };
    TableNode.prototype.setHeaderRow = function (row) {
        this.headerRow = row;
    };
    TableNode.prototype.getHeaderRowIndex = function () {
        var rows = this.getChildren();
        // assume body index starts with row that has a non-bold number in it.
        var bodyIndex = rows.findIndex(function (row) {
            return row.getChildren().some(function (col) { return typeof col.parseValue() === 'number' && !col.getText().includes('}}'); });
        });
        var getRowData = function (row) { return row.getChildren().map(function (col) { return col.parseValue(); }); };
        // if the header row is only one value, or empty, it's likely a label in the table body, so keep moving up.
        var headerIndex = bodyIndex - 1;
        while (rows[headerIndex] && getRowData(rows[headerIndex]).filter(Boolean).length <= 1 && headerIndex >= 0) {
            headerIndex--;
        }
        return headerIndex >= 0 ? headerIndex : null;
    };
    TableNode.prototype.mergeHeader = function (removeMergedChildren) {
        var _a, _b, _c;
        if (removeMergedChildren === void 0) { removeMergedChildren = true; }
        var headerRowIndex = (_a = this.getHeaderRowIndex()) !== null && _a !== void 0 ? _a : -1;
        var headerRow = (_b = this.getChildren()[headerRowIndex]) !== null && _b !== void 0 ? _b : null;
        if (!headerRow)
            return;
        var table = headerRow.toTable(false);
        var headerRowCols = headerRow.getChildren();
        // start from the row above the header row to merge.
        for (var rowIndex = headerRowIndex - 1; rowIndex >= 0; rowIndex--) {
            var curRow = table[rowIndex];
            // go through each header column to merge with the one above.
            for (var colIndex = 0; colIndex < curRow.length; colIndex++) {
                if (table[headerRowIndex][colIndex] === null)
                    continue;
                // if prev header col is empty, get nearest to the left.
                var colIndexCur = colIndex;
                while (!curRow[colIndexCur] && colIndexCur >= 0) {
                    colIndexCur--;
                }
                // if the value is empty, continue.
                var colValue = (_c = curRow[colIndexCur]) !== null && _c !== void 0 ? _c : null;
                if (!colValue || !this.parseValue("".concat(colValue)))
                    continue;
                headerRowCols[colIndex].setText("".concat(colValue, " ").concat(headerRowCols[colIndex].getText()).trim());
            }
        }
        if (removeMergedChildren) {
            while (this.getChildren()[0] !== headerRow && this.getChildren().length > 0) {
                this.removeTopChild();
            }
        }
        return headerRow;
    };
    /**
     * If header row is not set, this will try to find it.
     */
    TableNode.prototype.getHeaderRow = function () {
        var _a, _b, _c;
        return (_c = (_a = this.headerRow) !== null && _a !== void 0 ? _a : this.getChildren()[(_b = this.getHeaderRowIndex()) !== null && _b !== void 0 ? _b : -1]) !== null && _c !== void 0 ? _c : null;
    };
    return TableNode;
}(XMLNode_1.XMLNode));
exports.TableNode = TableNode;
